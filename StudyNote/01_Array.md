# Array (陣列)

## 核心概念
Array 是最基礎的資料結構，就是 **「一塊連續的記憶體空間」**，用來存一堆相同型別的東西。  
因為記憶體是連續的，電腦只要知道開頭在哪裡，就能瞬間算出任何一個元素的位置。

## Array能解決什麼問題？
「如何快速存取資料」的問題。只要給一個 **編號 (Index)**，不用從頭數，可以直接跳到那個位置抓資料。

## 核心特性
- **連續記憶體 (Contiguous Memory)**：元素一個接一個排列，就像鄰居住在隔壁，是它快速的原因，也是它難以擴充的原因。  
- **相同型別 (Same Data Type)**：存儲相同的資料型態，方便計算地址。  
- **隨機存取 (Random Access)**：不管要拿第 1 個還是第 10000 個，速度一樣快，都是 O(1)。

## 關鍵考點

### Static vs. Dynamic Array (必考比較)
| 特性 | Static Array (靜態) | Dynamic Array (動態) |
|---|---|---|
| 宣告 | `int arr[10];` | `int *arr = (int*)malloc(n * sizeof(int));` |
| 大小 | Compile time 決定 (固定) | Runtime 決定 (可變數) |
| 記憶體位置 | Stack (堆疊) | Heap (堆積) |
| 壽命 | 函式結束自動消失 | 需要手動 `free()`，不然會 Memory Leak |
| 擴充性 | 無法改變 | 可用 `realloc` 調整，但有代價 |

### 多維陣列的想像
- 1D Array：想像成「一列表格」。  ![]()
- 2D Array：想像成「表格」(Row, Column)。  ![]()
- 3D Array：想像成「好幾層表格」(Plane, Row, Column)。 ![]()

## 運作方式與操作邏輯

### 基本操作
- **Access (讀取)**：無敵快，直接算地址拿資料。  
- **Insert/Delete (插入/刪除)**：陣列的罩門。  
  因為記憶體是連續的，要在中間插隊 (Insert) 或抽走一個人 (Delete)，後面的所有人都必須大風吹 (Shift) 往後或往前移。  
  這就是為什麼說 Array 不適合頻繁的插入刪除，代價太高 (Costly shifts)。

### 排序演算法 (Sorting)
課堂上教了三種基礎排序，**要會畫圖、過程**。

- **Bubble Sort (泡沫排序)**：
![]()
  邏輯：兩兩相比，若前一個數字比後一個大就交換位置。

- **Selection Sort (選擇排序)**：  
![]()
  邏輯：每一輪找出最小值並將它跟未排序區的第一個數字交換位置。

- **Insertion Sort (插入排序)**：  
![]()
  邏輯：像打撲克牌理牌。拿到一張新牌 (Key)，在左邊已排好的區域中，從後往前掃，找到對的位置插進去。

### 搜尋演算法 (Searching)
- **Linear Search**：從頭看到尾，適用於未排序陣列，遍歷整個陣列，時間複雜度 O(n)。  
- **Binary Search**：適用於已排序陣列，次切一半，看目標在大半邊還是小半邊，效率很高，時間複雜度 O(log n)。

## 複雜度與實作
這張表是寫程式選擇資料結構的依據：

| 操作 | 時間複雜度 | 直覺/備註 |
|---|---|---|
| Access | O(1) | 陣列最強項，直接算地址。 |
| Update | O(1) | 知道位置直接改值。 |
| Insert | O(n) | 很慢，因為要搬移資料 (Shift)。 |
| Delete | O(n) | 很慢，刪掉後要把洞補起來。 |
| Search | O(n) | 未排序平均要找一半。 |
| Binary Search | O(\log n) | 超快，但資料必須先排序。 |

**實作建議**：
- 如果程式需要**頻繁讀取特定位置 (Read-heavy)** → **Array**  
- 如果程式需要一直**插隊、刪除 (Write-heavy/Dynamic)** → 用 Array 會卡死 →  [**Linked List**]()

## 容易搞混的地方與記憶重點

### 動態記憶體分配
- **malloc（記憶體分配）**：我想要一塊新的空間存東西，就用 malloc，分配好後它會給我一個指標指向這塊空間。  
  malloc 的特性：
  1. 內容未初始化：剛分配的空間裡面可能都是亂數，不要直接用。  
  2. 大小固定：如果之後想存更多或更少的東西，要用 realloc 或自己重新分配。  
  3. 記憶體釋放：用完一定要 `free()`，否則會記憶體洩漏。

- **realloc（動態記憶體調整）**：已經有一塊空間，但想變大或變小，用 realloc 動態調整它的大小。  
  realloc 的特性：
  1. 會保留原本資料：原本存的東西不會被清掉，但新增部分可能是垃圾值。  
  2. 可能搬家：如果原本空間不夠，它會在 Heap 上找新地方，然後把資料搬過去。  
  3. 回傳新指標：如果搬家了，原指標就不能再用，必須更新指標。  
  4. 釋放原本記憶體：如果 realloc 成功，它會自動處理原本的記憶體；失敗時，原本的記憶體還在，就要自己 `free()`。

- **總結**：
  - 第一次分配 → `malloc`  
  - 之後要改大小 → `realloc`  
  - 用完一定要 `free()` → 避免記憶體洩漏

### 字串 (String) 的長度
C 語言字串是 Character Array，但最後一定要有一個隱形的 `\0` (Null character) 結尾。  
範例：如果要存 `"Hello"` (5個字)，Array 至少要開 size 6，不然會爆掉。

### Reference
- 黃鈺峰教授，《CS203A 資料結構》課程簡報，作為本筆記 Array 相關內容之主要參考來源。  
- 部分內容與語句排版參考 AI Copilot 的建議，經整理與修正以符合教學筆記風格。