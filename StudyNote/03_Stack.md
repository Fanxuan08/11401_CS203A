# Stack (堆疊)

## 核心概念
- Stack 是一種受限的線性資料結構，遵循 **LIFO (Last-In, First-Out，後進先出)** 原則。  
- 想像一疊盤子或一桶洋芋片，你最後放進去的那一個，一定是第一個被拿出來的。
<img src="https://github.com/Fanxuan08/11401_CS203A/blob/main/StudyNote/參考圖片/Stack.jpg" alt="Stack" width="400">

## Stack能解決什麼問題？
- 適合處理「嵌套結構」或「回溯 (Backtracking)」的問題，需要暫存狀態以便稍後回復。

## 核心特性
- 所有操作（新增、刪除、查看）都在同一端進行，該端稱為 **Top (頂端)**。

## 關鍵考點
- **LIFO (後進先出)**：Stack 的核心概念。  
- **Top 是唯一出入口**：Push、Pop 等操作皆在 Top 進行。  
- **ADT 的體現**：Stack 是抽象資料型別，只要能實現 push 與 pop，底層可以用 Array 或 Linked List 實作。

## 運作方式與操作邏輯

### 基本操作（皆為 O(1) ）
- **Push (推入)**：將資料放到堆疊頂端。若用 Array 實作，top 索引加 1。  
- **Pop (彈出)**：取出頂端資料，top 索引減 1。  
- **Peek / Top (查看)**：查看頂端資料，不取出。  
- **IsEmpty / IsFull**：檢查堆疊是否為空或已滿，用於防止溢位或錯誤操作。  

> **設計理由**：限制操作於 Top 端，電腦無需搜尋整個結構或搬移資料，操作效率高，適合用於編譯器、作業系統等底層實作。

## 複雜度與實作

| 操作 | 時間複雜度 | 備註 |
|---|---|---|
| Push | O(1) | 直接在頂端加入資料 |
| Pop | O(1) | 直接從頂端取出資料 |
| Search | O(n) | Stack 本質不支援搜尋，要查底層資料需全部彈出 |

**實作應用**：
- **Undo (復原)**：返回上一狀態。  
- **括號匹配 (Parentheses)**：檢查括號是否成對。  
- **函式呼叫 (Function Call)**：呼叫過程中暫存返回狀態。  
- **反轉 (Reverse)**：將資料推入再彈出可得到相反順序。

## 容易搞混的地方與記憶重點

### 陣列實作：Top 的初始值
- Top 可定義為 -1 或 0。  
- 記憶規則：

  **Top = -1**：堆疊空，Push 時先加再放。  
  **Top = 0**：堆疊空，Top 指向下一個可用位置，Push 時先放再加。  
- 實作或考試前需確認 Top 定義。

### Array vs Linked List 實作
#### **Array**  
- 優點：速度快、記憶體連續  
- 缺點：固定大小，可能發生 Stack Overflow，擴充需搬移資料  

#### **Linked List**  
- 優點：可動態增長，無 Overflow 問題  
- 缺點：每個節點需存額外指標，記憶體開銷較大  

### 底部設計 (Array Bottom)
- 通常索引 0 作為底部，方便堆疊增長時向陣列後方延伸，不需搬移原資料。

## Reference
- 黃鈺峰教授，《CS203A 資料結構》課程簡報，作為本筆記 Stack 相關內容之主要參考來源。  
- 部分內容與語句排版參考 AI Copilot 的建議，經整理與修正以符合教學筆記風格。  
- 圖片來源：Scaler. [Stack in C](https://www.scaler.com/topics/stack-in-c/)，存取日期 2026-01-10。
